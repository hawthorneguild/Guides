---
layout: default
body_class: monster-page
background_image: /assets/images/fieldguide-back.png
extra_css:
  - /assets/css/statblock.css
---

<style>
    /* Grid container for the top stats line */
    .stat-grid-container {
        display: grid;
        grid-template-columns: max-content max-content; 
        justify-content: start;
        column-gap: 4em; 
        row-gap: 2px;
        margin-bottom: 1em;
    }

    .stat-cell-ac { grid-column: 1; }
    .stat-cell-init { grid-column: 2; text-align: left; }
    .stat-cell-hp { grid-column: 1 / -1; }
    .stat-cell-speed { grid-column: 1 / -1; }
    
    .stat-grid-container strong, .stat-grid-container b {
        font-weight: bold;
        color: #7a200d; 
    }
    /* FORCE BULLETS IN STAT BLOCKS */
    blockquote ul {
        list-style-type: disc !important; /* Forces the dot */
        padding-left: 2em !important;     /* Indents the list so dots are visible */
        margin-top: 0.5em;
        margin-bottom: 0.5em;
    }

    blockquote li {
        display: list-item !important;    /* Ensures it behaves like a list item */
        margin-bottom: 0.25em;            /* Adds a tiny space between items */
    }
    
    /* Optional: Fix nested paragraphs inside list items so they don't add extra space */
    blockquote li p {
        margin: 0;
        display: inline;
    }
</style>

{% if page.creator %}
<p class="creator-credit"><strong>Creator:</strong> {{ page.creator }}</p>
{% endif %}

{{ content }}

{% if page.image %}
<div class="monster-image-container">
    <img src="{{ page.image | relative_url }}" alt="Art of {{ page.title }}">
    {% if page.image_credit %}
    <p class="image-credit">{{ page.image_credit }}</p>
    {% endif %}
</div>
{% endif %}

{% if page.layout == "statblock" %}
<div class="export-button-container">
    <button class="btn back-button" onclick="window.location.href='{{ '/monster-compendium/' | relative_url }}'">‚Üê Back to Compendium Index</button>
    <button class="btn export-json-button" onclick="exportToJSON()">Export as JSON</button>
</div>
{% endif %}

<script>
    document.addEventListener("DOMContentLoaded", function() {
        formatStatLine();
        formatListsInBlockquotes();
    });

    function getStatBlockElement() {
        // Find the blockquote containing stats
        const blocks = document.querySelectorAll('blockquote');
        return Array.from(blocks).find(block => {
            const paragraphs = Array.from(block.querySelectorAll('p'));
            return paragraphs.some(p => {
                const text = p.textContent;
                return (text.includes('AC') || text.includes('Armor Class')) && 
                       (text.includes('HP') || text.includes('Hit Points'));
            });
        });
    }

    function formatListsInBlockquotes() {
        const statBlock = getStatBlockElement();
        if (!statBlock) return;

        const paragraphs = Array.from(statBlock.querySelectorAll('p'));
        
        paragraphs.forEach(p => {
            let html = p.innerHTML;
            
            // 1. SPLIT: Break the paragraph into lines based on <br> tags or newlines
            // We use a placeholder regex to keep the delimiter so we don't lose data
            let lines = html.split(/(<br\s*\/?>|\n)/i);
            
            let newHtml = '';
            let inList = false;

            // We iterate chunks. Some are text, some are <br>.
            for (let i = 0; i < lines.length; i++) {
                let line = lines[i];
                
                // Skip literal <br> tags in the loop, we handle breaks via list logic
                if (line.match(/<br\s*\/?>/i) || line === '\n') continue;

                let cleanLine = line.trim();
                if (!cleanLine) continue;

                // 2. DETECT: Check for List Candidates
                // Case A: Starts with a dash "- "
                const isDash = cleanLine.match(/^-\s+/);
                
                // Case B: Starts with an asterisk "* " (literal)
                const isStar = cleanLine.match(/^\*\s+/);
                
                // Case C: Starts with Italics "<em>" that was meant to be a bullet
                // (Parser swallowed the * and made it <em>)
                let isItalicBullet = false;
                if (cleanLine.startsWith('<em>') || cleanLine.startsWith('<i>')) {
                    // Check if it looks like a full sentence or header inside italics
                    // If the italics wrap the WHOLE line, it's likely a bullet error.
                    // If the italics end quickly (e.g. <em>Melee Attack:</em>), it's just a header.
                    
                    // Simple heuristic: If it was > * Text, it became > <em>Text</em>.
                    // We assume ALL starting italics in these specific sections are list items 
                    // unless they are followed by immediate text on the same line.
                    isItalicBullet = true;
                }

                if (isDash || isStar || isItalicBullet) {
                    if (!inList) {
                        newHtml += '<ul>';
                        inList = true;
                    }

                    let content = cleanLine;

                    // CLEANUP: Remove the marker that triggered the list
                    if (isDash) content = content.replace(/^-\s+/, '');
                    if (isStar) content = content.replace(/^\*\s+/, '');
                    if (isItalicBullet) {
                        // If it's an italic bullet, we usually want to KEEP the italics 
                        // because they likely indicate a spell name or feature name.
                        // We just wrap it in <li>.
                        // However, if the parser italicized the whole line purely due to the bullet error,
                        // you might strictly want to strip it. 
                        // For now, we keep the italics as they might be intentional formatting (like spell names).
                    }

                    newHtml += `<li>${content}</li>`;
                } else {
                    // Not a list item
                    if (inList) {
                        newHtml += '</ul>';
                        inList = false;
                    }
                    // Append text with a trailing space/break if needed
                    newHtml += (newHtml ? '<br>' : '') + line;
                }
            }

            if (inList) newHtml += '</ul>';

            // Only update DOM if we actually built a list
            if (newHtml.includes('<ul>')) {
                p.innerHTML = newHtml;
            }
        });
    }

    function formatStatLine() {
        const statBlock = getStatBlockElement();
        if (!statBlock) return;

        const paragraphs = Array.from(statBlock.querySelectorAll('p'));
        const statP = paragraphs.find(p => {
            const text = p.textContent;
            return (text.includes('AC') || text.includes('Armor Class')) && 
                   (text.includes('HP') || text.includes('Hit Points'));
        });
        
        if (!statP) return;

        let html = statP.innerHTML;
        const tagRegex = "(?:<(?:strong|b)>)";
        const closeTagRegex = "(?:<\/(?:strong|b)>)";
        const acLabelPattern = "(?:AC|Armor Class)";
        const hpLabelPattern = "(?:HP|Hit Points)";
        
        const acRegex = new RegExp(`(${tagRegex}${acLabelPattern}${closeTagRegex}[\\s\\S]*?)(?=${tagRegex}${hpLabelPattern})`, 'i');
        const hpRegex = new RegExp(`(${tagRegex}${hpLabelPattern}${closeTagRegex}[\\s\\S]*?)(?=${tagRegex}Speed)`, 'i');
        
        const acMatch = html.match(acRegex);
        const hpMatch = html.match(hpRegex);
        
        if (acMatch && hpMatch) {
            let acHtml = acMatch[1].trim().replace(/<br\s*\/?>$/i, '').replace(/Armor Class/, 'AC');
            let hpHtml = hpMatch[1].trim().replace(/<br\s*\/?>$/i, '').replace(/Hit Points/, 'HP');
            
            let speedRegex = new RegExp(`(${tagRegex}Speed${closeTagRegex}[\\s\\S]*?)(?=${tagRegex}Initiative|$)`, 'i');
            let speedMatch = html.match(speedRegex);
            let speedHtml = speedMatch ? speedMatch[1].trim().replace(/<br\s*\/?>$/i, '') : "";
            
            let initHtml = "";
            const initTagRegex = new RegExp(`(${tagRegex}Initiative${closeTagRegex})\\s*([\\s\\S]*)`, 'i');
            let initMatch = html.match(initTagRegex);
            
            if (!initMatch) {
                const nextP = statP.nextElementSibling;
                if (nextP && nextP.tagName === 'P') {
                    const nextHtml = nextP.innerHTML;
                    if (nextHtml.match(new RegExp(`^${tagRegex}Initiative`, 'i'))) {
                        initMatch = nextHtml.match(initTagRegex);
                        if (initMatch) nextP.remove();
                    }
                }
            }

            if (initMatch) {
                const initLabel = initMatch[1]; 
                const rawValues = initMatch[2];
                const swapMatch = rawValues.match(/^\s*(\([+-]\d+\))\s*(\d+)/);
                if (swapMatch) {
                     initHtml = `${initLabel} ${swapMatch[1].replace(/[()]/g, '')} (${swapMatch[2]})`;
                } else {
                    initHtml = `${initLabel} ${rawValues}`;
                }
            }
            
            speedHtml = speedHtml.replace(new RegExp(`${tagRegex}Initiative.*`, 'i'), '').trim();

            const newContainer = document.createElement('div');
            newContainer.className = 'stat-grid-container';
            newContainer.innerHTML = `
                <div class="stat-cell-ac">${acHtml}</div>
                ${initHtml ? `<div class="stat-cell-init">${initHtml}</div>` : ''}
                <div class="stat-cell-hp">${hpHtml}</div>
                <div class="stat-cell-speed">${speedHtml}</div>
            `;

            statP.parentNode.replaceChild(newContainer, statP);
        }
    }
</script>