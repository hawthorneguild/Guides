---
layout: default
title: Hawthorne Monster Compendium
background_image: /assets/images/fieldguide-back.png
extra_css:
  - /assets/css/statblock.css
---

<h2>Hawthorne Monsters Compendium</h2>
<p>The monsters in this compendium have been created by various members of the community of the Hawthorne Dungeons & Dragons Guild. The credits are listed on the footer of the monster pages.</p>

<p>If you are a DM and would like to submit a monster that can be used by DMs across the server, <a href="{{ site.baseurl }}/monster-compendium/monsters-submit/">follow the instructions here.</a> </p>

<h3>Filter Monsters</h3>
<p>Use the filter below to quickly find monsters by type, size and CR.   To search by Monster Name, use your browser's search function (Ctrl+F or Cmd+F).
  <br>2014 Fair Game monsters are open to all DMs to use.  2014 Full DM monsters (as the name implies) require the <span class="role-full-dm">Full DM</span> tag to use.</p>

<div class="filter-container">
  <div class="filter-group">
    <label for="type-filter">Type:</label>
    <select id="type-filter" class="filter-select">
      <option value="">All Types</option>
    </select>
  </div>
  
  <div class="filter-group">
    <label for="cr-from">CR From:</label>
    <input type="number" id="cr-from" class="filter-input" placeholder="Min" min="0" step="0.125">
  </div>
  
  <div class="filter-group">
    <label for="cr-to">CR To:</label>
    <input type="number" id="cr-to" class="filter-input" placeholder="Max" min="0" step="0.125">
  </div>
  
  <div class="filter-group">
    <label for="size-filter">Size:</label>
    <select id="size-filter" class="filter-select">
      <option value="">All Sizes</option>
    </select>
  </div>
  
  <button id="reset-filters" class="reset-button">Reset Filters</button>
</div>

<div id="monster-count" class="monster-count"></div>

{% assign monsters_by_category = site.monsters | where_exp:"item", "item.category != null" | group_by: 'category' %}

{% for category in monsters_by_category %}
  <div class="category-section" data-category="{{ category.name }}">
    <h2 class="category-title">
      <button class="category-toggle" aria-expanded="true">
        <span class="toggle-icon">â–¼</span>
        {{ category.name }}
      </button>
    </h2>

    <div class="monster-list">
      {% for monster in category.items %}
        <div class="monster-card" 
             data-cr="{{ monster.cr }}" 
             data-type="{{ monster.type }}" 
             data-size="{{ monster.size }}">
          {% if monster.image %}
          <div class="monster-card-image">
            <img src="{{ monster.image | relative_url }}" alt="{{ monster.title }}">
          </div>
          {% endif %}
          <div class="monster-card-content">
            <h3><a href="{{ monster.url | relative_url }}">{{ monster.title }}</a></h3>
            <p class="monster-cr">CR {{ monster.cr }}</p>
            <p class="monster-type">{{ monster.type }}</p>
          </div>
        </div>
      {% endfor %}
    </div>
  </div>
{% endfor %}

<style>
.filter-container {
  background: #FDF1DC;
  border: 2px solid var(--color-primary);
  border-radius: 0px;
  padding: 1.5em;
  margin: 2em 0;
  display: flex;
  flex-wrap: wrap;
  gap: 1em;
  align-items: flex-end;
}

.filter-group {
  display: flex;
  flex-direction: column;
  gap: 0.5em;
  flex: 1;
  min-width: 150px;
}

.filter-group label {
  font-family: var(--font-header);
  font-weight: 700;
  color: var(--color-primary);
  text-transform: uppercase;
  font-size: 0.9em;
  letter-spacing: 0.5px;
}

.filter-select {
  padding: 0.5em;
  border: 2px solid var(--color-primary);
  border-radius: 0px;
  background: white;
  font-family: var(--font-body);
  font-size: 1em;
  color: var(--color-primary);
  cursor: pointer;
}

.filter-select:focus {
  outline: none;
  border-color: var(--color-secondary);
  box-shadow: 0 0 0 2px rgba(88, 24, 13, 0.2);
}

.filter-input {
  padding: 0.5em;
  border: 2px solid var(--color-primary);
  border-radius: 0px;
  background: white;
  font-family: var(--font-body);
  font-size: 1em;
  color: var(--color-primary);
  width: 100%;
}

.filter-input:focus {
  outline: none;
  border-color: var(--color-secondary);
  box-shadow: 0 0 0 2px rgba(88, 24, 13, 0.2);
}

.filter-input::placeholder {
  color: #999;
  font-style: italic;
}

.reset-button {
  padding: 0.5em 1.5em;
  background: var(--color-primary);
  color: #FDF1DC;
  border: none;
  border-radius: 0px;
  font-family: var(--font-header);
  font-size: 0.9em;
  text-transform: uppercase;
  cursor: pointer;
  transition: background 0.2s;
  height: fit-content;
}

.reset-button:hover {
  background: var(--color-secondary);
}

.monster-count {
  font-family: var(--font-body);
  font-style: italic;
  color:var(--color-primary);
  margin: 1em 0;
  font-size: 0.95em;
}

.category-section {
  margin-bottom: 2em;
}

.category-section.hidden {
  display: none;
}

.category-toggle {
  background: none;
  border: none;
  font-family: var(--font-header);
  font-size: 1.0em;
  font-weight: 700;
  color: var( --color-secondary);
  cursor: pointer;
  padding: 0.5em 0;
  width: 100%;
  text-align: left;
  display: flex;
  align-items: center;
  gap: 0.5em;
  transition: color 0.2s;
}

.category-toggle:hover {
  color: var(--color-secondary);
}

.toggle-icon {
  display: inline-block;
  transition: transform 0.3s ease;
  font-size: 0.8em;
}

.category-toggle[aria-expanded="false"] .toggle-icon {
  transform: rotate(-90deg);
}

.category-section[aria-expanded="false"] .monster-list {
  display: none;
}

/* FIX: Removed the !important from display: flex to allow the .hidden class to work */
.monster-list .monster-card {
  display: flex; 
  gap: 1em;
  align-items: center;
}

.monster-list .monster-card-image {
  flex-shrink: 0;
  width: 80px !important;
  height: 80px !important;
  overflow: hidden;
  border-radius: 0px;
  border: 2px solid var(--color-primary);
}

.monster-list .monster-card-image img {
  width: 100% !important;
  height: 100% !important;
  max-width: 80px !important;
  max-height: 80px !important;
  object-fit: cover;
  display: block;
}

.monster-list .monster-card-content {
  flex: 1;
  min-width: 0;
}

.monster-card.hidden {
  display: none;
}

@media (max-width: 768px) {
  .filter-container {
    flex-direction: column;
    align-items: stretch;
  }
  
  .filter-group {
    min-width: 100%;
  }
  
  .reset-button {
    width: 100%;
  }
}
</style>

<script>
document.addEventListener('DOMContentLoaded', function() {
  const typeFilter = document.getElementById('type-filter');
  const crFromInput = document.getElementById('cr-from');
  const crToInput = document.getElementById('cr-to');
  const sizeFilter = document.getElementById('size-filter');
  const resetButton = document.getElementById('reset-filters');
  const monsterCards = document.querySelectorAll('.monster-card');
  const categorySections = document.querySelectorAll('.category-section');
  const monsterCount = document.getElementById('monster-count');
  
  // Function to parse CR values (handles fractions like "1/4")
  function parseCR(crString) {
    // If the data attribute is missing or empty, return a very high number 
    if (!crString) return 9999; 
    
    // Check if it's a fraction
    if (crString.includes('/')) {
      const parts = crString.split('/');
      return parseFloat(parts[0]) / parseFloat(parts[1]);
    }
    
    return parseFloat(crString);
  }
  
  // Collect unique values for filters
  const types = new Set();
  const sizes = new Set();
  
  monsterCards.forEach(card => {
    const type = card.dataset.type;
    const size = card.dataset.size;
    
    if (type) types.add(type);
    if (size) sizes.add(size);
  });
    // Add collapse/expand functionality
  const categoryToggles = document.querySelectorAll('.category-toggle');
  categoryToggles.forEach(toggle => {
    toggle.addEventListener('click', function() {
      const isExpanded = this.getAttribute('aria-expanded') === 'true';
      this.setAttribute('aria-expanded', !isExpanded);
      
      const section = this.closest('.category-section');
      section.setAttribute('aria-expanded', !isExpanded);
    });
  });
  
  // Populate filter dropdowns
  Array.from(types).sort().forEach(type => {
    const option = document.createElement('option');
    option.value = type;
    option.textContent = type;
    typeFilter.appendChild(option);
  });
  
  // Sort sizes by D&D standard order
  const sizeOrder = ['Tiny', 'Small', 'Medium', 'Large', 'Huge', 'Gargantuan'];
  Array.from(sizes).sort((a, b) => {
    return sizeOrder.indexOf(a) - sizeOrder.indexOf(b);
  }).forEach(size => {
    const option = document.createElement('option');
    option.value = size;
    option.textContent = size;
    sizeFilter.appendChild(option);
  });
  
  // Filter function
  function filterMonsters() {
    const selectedType = typeFilter.value;
    const crFrom = crFromInput.value ? Number(crFromInput.value) : null; 
    const crTo = crToInput.value ? Number(crToInput.value) : null;
    const selectedSize = sizeFilter.value;
    
    let visibleCount = 0;
    
    monsterCards.forEach(card => {
      const cardType = card.dataset.type;
      const cardCR = parseCR(card.dataset.cr);
      const cardSize = card.dataset.size;
      
      const typeMatch = !selectedType || cardType === selectedType;
      const sizeMatch = !selectedSize || cardSize === selectedSize;
      
      // CR range matching
      let crMatch = true;
      if (crFrom !== null && cardCR < crFrom) {
        crMatch = false;
      }
      if (crTo !== null && cardCR > crTo) {
        crMatch = false;
      }
      
      // Apply visibility based on all matches
      if (typeMatch && crMatch && sizeMatch) {
        card.classList.remove('hidden');
        visibleCount++;
      } else {
        // Correctly hide non-matches
        card.classList.add('hidden'); 
      }
    });
    
    // This correctly sorts all monsters (visible first by CR, hidden last) and re-appends ALL
    categorySections.forEach(section => {
      const monsterList = section.querySelector('.monster-list');
      const allCards = Array.from(monsterList.querySelectorAll('.monster-card'));
      
      // Custom sort logic
      allCards.sort((a, b) => {
        const aIsHidden = a.classList.contains('hidden');
        const bIsHidden = b.classList.contains('hidden');
        
        // Rule 1: Visible cards (-1) come before hidden cards (1)
        if (aIsHidden && !bIsHidden) return 1;
        if (!aIsHidden && bIsHidden) return -1;
        
        // Rule 2: If visibility is the same, sort by CR
        const crA = parseCR(a.dataset.cr);
        const crB = parseCR(b.dataset.cr);
        return crA - crB;
      });
      
      // Re-append ALL cards to fix the DOM order
      allCards.forEach(card => monsterList.appendChild(card));
    });
      
    // Hide/show category sections based on visible monsters
    categorySections.forEach(section => {
      const visibleCardsInSection = section.querySelectorAll('.monster-card:not(.hidden)');
      if (visibleCardsInSection.length === 0) {
        section.classList.add('hidden');
      } else {
        section.classList.remove('hidden');
      }
    });
    
    // Update count
    const totalCount = monsterCards.length;
    monsterCount.textContent = `Showing ${visibleCount} of ${totalCount} monsters`;
  }
  
  // Reset function
  function resetFilters() {
    typeFilter.value = '';
    crFromInput.value = '';
    crToInput.value = '';
    sizeFilter.value = '';
    filterMonsters();
  }
  
  // Add event listeners
  typeFilter.addEventListener('change', filterMonsters);
  crFromInput.addEventListener('input', filterMonsters);
  crToInput.addEventListener('input', filterMonsters);
  sizeFilter.addEventListener('change', filterMonsters);
  resetButton.addEventListener('click', resetFilters);
  
  // Initial count and filter execution
  filterMonsters();
});
</script>