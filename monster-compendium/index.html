---
layout: default
title: Hawthorne Monster Compendium
background_image: /assets/images/fieldguide-back.png
extra_css:
  - /assets/css/statblock.css
---

<h2>Hawthorne Monsters Compendium</h2>
<p>The monsters in this compendium have been created by various members of the community of the Hawthorne Dungeons & Dragons Guild. The credits are listed on the footer of the monster pages.</p>

<p>If you are a DM and would like to submit a monster that can be used by DMs across the server, <a href="{{ site.baseurl }}/monster-compendium/monsters-submit/">follow the instructions here.</a> </p>

<h3>Filter Monsters</h3>
<p>Use the filter below to quickly find monsters by name, type, size and CR.
  <br>2014 Fair Game monsters are open to all DMs to use.  2014 Full DM monsters (as the name implies) require the <span class="role-full-dm">Full DM</span> tag to use.</p>

<!-- ============================================ -->
<!-- FILTER UI CONTROLS -->
<!-- Inputs for name search, type, CR range, and size filtering -->
<!-- ============================================ -->
<div class="filter-container">
  <div class="filter-group">
    <label for="name-search">Name:</label>
    <input type="text" id="name-search" class="filter-input" placeholder="Search by name...">
  </div>
  <div class="filter-group">
    <label for="type-filter">Type:</label>
    <select id="type-filter" class="filter-select">
      <option value="">All Types</option>
    </select>
  </div>
  
  <div class="filter-group">
    <label for="cr-from">CR From:</label>
    <input type="number" id="cr-from" class="filter-input" placeholder="Min" min="0" step="0.125">
  </div>
  
  <div class="filter-group">
    <label for="cr-to">CR To:</label>
    <input type="number" id="cr-to" class="filter-input" placeholder="Max" min="0" step="0.125">
  </div>
  
  <div class="filter-group">
    <label for="size-filter">Size:</label>
    <select id="size-filter" class="filter-select">
      <option value="">All Sizes</option>
    </select>
  </div>
  
  <button id="reset-filters" class="reset-button">Reset Filters</button>
</div>

<!-- Monster count display - shows "X of Y monsters" -->
<div id="monster-count" class="monster-count"></div>

<!-- ============================================ -->
<!-- MONSTER LISTING BY CATEGORY -->
<!-- Jekyll liquid template generates categories and monster cards -->
<!-- ============================================ -->
{% assign monsters_by_category = site.monsters | where_exp:"item", "item.category != null" | group_by: 'category' %}

{% for category in monsters_by_category %}
  <div class="category-section" data-category="{{ category.name }}">
    <h2 class="category-title">
      <button class="category-toggle" aria-expanded="true">
        <span class="toggle-icon">â–¼</span>
        {{ category.name }}
      </button>
    </h2>

    <div class="monster-list">
      {% for monster in category.items %}
        <!-- Each monster card contains filter data attributes -->
        <div class="monster-card" 
             data-cr="{{ monster.cr }}" 
             data-type="{{ monster.type }}" 
             data-size="{{ monster.size }}">
          {% if monster.image %}
          <div class="monster-card-image">
            <img src="{{ monster.image | relative_url }}" alt="{{ monster.title }}">
          </div>
          {% endif %}
          <div class="monster-card-content">
            <h3><a href="{{ monster.url | relative_url }}">{{ monster.title }}</a></h3>
            <p class="monster-cr">CR {{ monster.cr }}</p>
            <p class="monster-type">{{ monster.type }}</p>
          </div>
        </div>
      {% endfor %}
    </div>
  </div>
{% endfor %}

<a href="https://www.artstation.com/mandryk">Background Image:  Goblin Chaos by David Mandryk</a>

<!-- ============================================ -->
<!-- FILTER UI STYLES -->
<!-- All CSS for the filter interface -->
<!-- ============================================ -->
<style>
/* Main container for all filter controls */
.filter-container {
  background: #FDF1DC;
  border: 2px solid var(--color-primary);
  border-radius: 0px;
  padding: 1.5em;
  margin: 2em 0;
  display: flex;
  flex-wrap: wrap;
  gap: 1em;
  align-items: flex-end; /* Aligns button with inputs */
}

/* Individual filter input group (label + input/select) */
.filter-group {
  display: flex;
  flex-direction: column;
  gap: 0.5em;
  flex: 1;
  min-width: 150px; /* Prevents inputs from getting too narrow */
}

/* Filter labels styling */
.filter-group label {
  font-family: var(--font-header);
  font-weight: 700;
  color: var(--color-primary);
  text-transform: uppercase;
  font-size: 0.9em;
  letter-spacing: 0.5px;
}

/* Dropdown select boxes */
.filter-select {
  padding: 0.5em;
  border: 2px solid var(--color-primary);
  border-radius: 0px;
  background: white;
  font-family: var(--font-body);
  font-size: 1em;
  color: var(--color-primary);
  cursor: pointer;
}

.filter-select:focus {
  outline: none;
  border-color: var(--color-secondary);
  box-shadow: 0 0 0 2px rgba(88, 24, 13, 0.2);
}

/* Text and number input fields */
.filter-input {
  padding: 0.5em;
  border: 2px solid var(--color-primary);
  border-radius: 0px;
  background: white;
  font-family: var(--font-body);
  font-size: 1em;
  color: var(--color-primary);
  width: 100%;
}

.filter-input:focus {
  outline: none;
  border-color: var(--color-secondary);
  box-shadow: 0 0 0 2px rgba(88, 24, 13, 0.2);
}

.filter-input::placeholder {
  color: #999;
  font-style: italic;
}

/* Reset filters button */
.reset-button {
  padding: 0.5em 1.5em;
  background: var(--color-primary);
  color: #FDF1DC;
  border: none;
  border-radius: 0px;
  font-family: var(--font-header);
  font-size: 0.9em;
  text-transform: uppercase;
  cursor: pointer;
  transition: background 0.2s;
  height: fit-content; /* Matches height with input fields */
}

.reset-button:hover {
  background: var(--color-secondary);
}

/* "Showing X of Y monsters" text */
.monster-count {
  font-family: var(--font-body);
  font-style: italic;
  color:var(--color-primary);
  margin: 1em 0;
  font-size: 0.95em;
}

/* ============================================ */
/* CATEGORY SECTION STYLES */
/* Collapsible category headers and containers */
/* ============================================ -->
.category-section {
  margin-bottom: 2em;
}

/* Hide entire category when no monsters match filters */
.category-section.hidden {
  display: none;
}

/* Collapsible category header button */
.category-toggle {
  background: none;
  border: none;
  font-family: var(--font-header);
  font-size: 1.0em;
  font-weight: 700;
  color: var( --color-secondary);
  cursor: pointer;
  padding: 0.5em 0;
  width: 100%;
  text-align: left;
  display: flex;
  align-items: center;
  gap: 0.5em;
  transition: color 0.2s;
}

.category-toggle:hover {
  color: var(--color-secondary);
}

/* Arrow icon that rotates when collapsed */
.toggle-icon {
  display: inline-block;
  transition: transform 0.3s ease;
  font-size: 0.8em;
}

/* Rotated arrow for collapsed state */
.category-toggle[aria-expanded="false"] .toggle-icon {
  transform: rotate(-90deg);
}

/* Hide monster list when category is collapsed */
.category-section[aria-expanded="false"] .monster-list {
  display: none;
}

/* ============================================ */
/* MONSTER CARD STYLES */
/* Layout for individual monster cards */
/* ============================================ -->
/* Monster card layout - horizontal with image and content */
.monster-list .monster-card {
  display: flex; /* Removed !important to allow .hidden class to work */
  gap: 1em;
  align-items: center;
}

/* Monster thumbnail image container */
.monster-list .monster-card-image {
  flex-shrink: 0;
  width: 80px !important;
  height: 80px !important;
  overflow: hidden;
  border-radius: 0px;
  border: 2px solid var(--color-primary);
}

/* Monster thumbnail image */
.monster-list .monster-card-image img {
  width: 100% !important;
  height: 100% !important;
  max-width: 80px !important;
  max-height: 80px !important;
  object-fit: cover;
  display: block;
}

/* Monster card text content area */
.monster-list .monster-card-content {
  flex: 1;
  min-width: 0; /* Prevents text overflow issues */
}

/* Hide filtered out monster cards */
.monster-card.hidden {
  display: none;
}

/* ============================================ */
/* RESPONSIVE DESIGN - MOBILE */
/* Stack filters vertically on small screens */
/* ============================================ -->
@media (max-width: 768px) {
  .filter-container {
    flex-direction: column;
    align-items: stretch;
  }
  
  .filter-group {
    min-width: 100%;
  }
  
  .reset-button {
    width: 100%;
  }
}
</style>

<!-- ============================================ -->
<!-- FILTERING AND SORTING JAVASCRIPT -->
<!-- Handles all interactive filtering functionality -->
<!-- ============================================ -->
<script>
document.addEventListener('DOMContentLoaded', function() {
  // ==========================================
  // GET DOM ELEMENTS
  // ==========================================
  const nameSearchInput = document.getElementById('name-search');
  const typeFilter = document.getElementById('type-filter');
  const crFromInput = document.getElementById('cr-from');
  const crToInput = document.getElementById('cr-to');
  const sizeFilter = document.getElementById('size-filter');
  const resetButton = document.getElementById('reset-filters');
  const monsterCards = document.querySelectorAll('.monster-card');
  const categorySections = document.querySelectorAll('.category-section');
  const monsterCount = document.getElementById('monster-count');
  
  // ==========================================
  // HELPER FUNCTIONS
  // ==========================================
  
  /**
   * Parse CR string to number
   * Handles fractions like "1/4" and standard numbers
   * @param {string} crString - CR value from data attribute
   * @returns {number} Numeric CR value
   */
  function parseCR(crString) {
    // Return high number if CR is missing
    if (!crString) return 9999; 
    
    // Handle fractional CRs (e.g., "1/4" = 0.25)
    if (crString.includes('/')) {
      const parts = crString.split('/');
      return parseFloat(parts[0]) / parseFloat(parts[1]);
    }
    
    return parseFloat(crString);
  }
  
  // ==========================================
  // POPULATE FILTER DROPDOWNS
  // Extract unique types and sizes from monster data
  // ==========================================
  const types = new Set();
  const sizes = new Set();
  
  monsterCards.forEach(card => {
    const type = card.dataset.type;
    const size = card.dataset.size;
    
    if (type) types.add(type);
    if (size) sizes.add(size);
  });
    
  // ==========================================
  // CATEGORY COLLAPSE/EXPAND FUNCTIONALITY
  // ==========================================
  const categoryToggles = document.querySelectorAll('.category-toggle');
  categoryToggles.forEach(toggle => {
    toggle.addEventListener('click', function() {
      const isExpanded = this.getAttribute('aria-expanded') === 'true';
      this.setAttribute('aria-expanded', !isExpanded);
      
      const section = this.closest('.category-section');
      section.setAttribute('aria-expanded', !isExpanded);
    });
  });
  
  // ==========================================
  // POPULATE TYPE DROPDOWN
  // Add all unique monster types alphabetically
  // ==========================================
  Array.from(types).sort().forEach(type => {
    const option = document.createElement('option');
    option.value = type;
    option.textContent = type;
    typeFilter.appendChild(option);
  });
  
  // ==========================================
  // POPULATE SIZE DROPDOWN
  // Sort by D&D standard size order
  // ==========================================
  const sizeOrder = ['Tiny', 'Small', 'Medium', 'Large', 'Huge', 'Gargantuan'];
  Array.from(sizes).sort((a, b) => {
    return sizeOrder.indexOf(a) - sizeOrder.indexOf(b);
  }).forEach(size => {
    const option = document.createElement('option');
    option.value = size;
    option.textContent = size;
    sizeFilter.appendChild(option);
  });
  
  // ==========================================
  // MAIN FILTER FUNCTION
  // Filters and sorts monsters based on all criteria
  // ==========================================
  function filterMonsters() {
    // Get current filter values
    const selectedType = typeFilter.value;
    const crFrom = crFromInput.value ? Number(crFromInput.value) : null; 
    const crTo = crToInput.value ? Number(crToInput.value) : null;
    const selectedSize = sizeFilter.value;
    const selectedName = nameSearchInput.value.toLowerCase().trim();
    
    let visibleCount = 0;
    
    // ==========================================
    // FILTER EACH MONSTER CARD
    // Show/hide based on all filter criteria
    // ==========================================
    monsterCards.forEach(card => {
      const cardType = card.dataset.type;
      const cardCR = parseCR(card.dataset.cr);
      const cardSize = card.dataset.size;
      const cardName = card.querySelector('h3 a').textContent.toLowerCase();
      
      // Check each filter criterion
      const typeMatch = !selectedType || cardType === selectedType;
      const sizeMatch = !selectedSize || cardSize === selectedSize;
      const nameMatch = !selectedName || cardName.includes(selectedName);
      
      // CR range matching
      let crMatch = true;
      if (crFrom !== null && cardCR < crFrom) {
        crMatch = false;
      }
      if (crTo !== null && cardCR > crTo) {
        crMatch = false;
      }
      
      // Apply visibility based on all matches
      if (typeMatch && crMatch && sizeMatch && nameMatch) {
        card.classList.remove('hidden');
        visibleCount++;
      } else {
        card.classList.add('hidden');
      }
    });
    
    // ==========================================
    // SORT MONSTERS WITHIN CATEGORIES
    // Visible monsters sorted by CR, hidden at end
    // ==========================================
    categorySections.forEach(section => {
      const monsterList = section.querySelector('.monster-list');
      const allCards = Array.from(monsterList.querySelectorAll('.monster-card'));
      
      // Custom sort: visible first (by CR), then hidden
      allCards.sort((a, b) => {
        const aIsHidden = a.classList.contains('hidden');
        const bIsHidden = b.classList.contains('hidden');
        
        // Visible cards come before hidden cards
        if (aIsHidden && !bIsHidden) return 1;
        if (!aIsHidden && bIsHidden) return -1;
        
        // If same visibility, sort by CR
        const crA = parseCR(a.dataset.cr);
        const crB = parseCR(b.dataset.cr);
        return crA - crB;
      });
      
      // Re-append cards in sorted order
      allCards.forEach(card => monsterList.appendChild(card));
    });
      
    // ==========================================
    // HIDE EMPTY CATEGORIES
    // Categories with no visible monsters are hidden
    // ==========================================
    categorySections.forEach(section => {
      const visibleCardsInSection = section.querySelectorAll('.monster-card:not(.hidden)');
      if (visibleCardsInSection.length === 0) {
        section.classList.add('hidden');
      } else {
        section.classList.remove('hidden');
      }
    });
    
    // Update count display
    const totalCount = monsterCards.length;
    monsterCount.textContent = `Showing ${visibleCount} of ${totalCount} monsters`;
  }
  
  // ==========================================
  // RESET ALL FILTERS
  // Clear all inputs and show all monsters
  // ==========================================
  function resetFilters() {
    typeFilter.value = '';
    crFromInput.value = '';
    crToInput.value = '';
    sizeFilter.value = '';
    nameSearchInput.value = '';
    filterMonsters();
  }
  
  // ==========================================
  // EVENT LISTENERS
  // Attach filter function to all inputs
  // ==========================================
  typeFilter.addEventListener('change', filterMonsters);
  crFromInput.addEventListener('input', filterMonsters);
  crToInput.addEventListener('input', filterMonsters);
  sizeFilter.addEventListener('change', filterMonsters);
  nameSearchInput.addEventListener('input', filterMonsters);
  resetButton.addEventListener('click', resetFilters);
  
  // Initialize - show count and apply any default filters
  filterMonsters();
});
</script>