/**
 * This is an "Immediately Invoked Function Expression" (IIFE).
 * It's a common JavaScript pattern that wraps the entire script in a function
 * and then immediately calls it. This prevents variables from "leaking" into
 * the global scope (i.e., it keeps our variables private to this script).
 * 
 * Location: \assets\js\search.js
 
 */
(function() {
  
  // --- 1. Get references to the HTML elements we need ---
  
  // Find the <input> element where the user types their search
  var search = document.getElementById('search-input');
  // Find the <ul> or <div> element where we will display the results
  var results = document.getElementById('search-results');
  
  // --- 2. Initialize variables ---
  
  // 'index' will hold our Lunr.js search index object once it's built.
  // Lunr.js is a small, fast, full-text search library that runs in the browser.
  var index = null;
  
  // 'store' will be a simple JavaScript object (like a dictionary or hash map)
  // that holds the *actual* document data (title, content).
  //
  // WHY? Lunr.js is optimized for size. When it finds a match, it only
  // returns the 'reference' (e.g., the URL) of the matching document,
  // not the full title or content. We use this 'store' to look up
  // the title/content using the URL that Lunr gives us.
  var store = {};

  // --- 3. Check if the required HTML elements exist ---
  
  // If the search box or results container aren't on this specific page,
  // there's no point in running the rest of the script. We'll just stop.
  if (!search || !results) {
    return;
  }

  // --- 4. Fetch the search data and build the index ---
  
  // Asynchronously fetch the 'search.json' file.
  // This file is typically generated by a static site generator (like Jekyll)
  // and contains all the text from all pages on the site.
  // 'BASE_URL' is likely a global variable set in your site's config.
  fetch(BASE_URL + '/search.json') 
    .then(response => response.json()) // Parse the response text as JSON
    .then(data => {
      // SUCCESS! 'data' is now an array of all our site's documents.
      
      // Build the Lunr.js index.
      index = lunr(function () {
        
        // --- CHANGE 1: Tell Lunr to store token positions ---
        // This is the magic line that makes contextual snippets possible.
        // It tells Lunr to save the [start, length] position of each
        // word in its metadata.
        this.metadataWhitelist.push('position');
        // ----------------------------------------------------

        // Tell Lunr which fields from our JSON data to index.
        // 'boost: 10' makes a match in the 'title' 10 times more important
        // (i.e., higher-scoring) than a match in the 'content'.
        this.field('title', { boost: 20 });
        this.field('headers', { boost: 10 });
        this.field('content', { boost: 2 }); 
        
        // Tell Lunr what to use as the unique identifier for each document.
        // When we search, Lunr will give us this 'ref' back.
        this.ref('url');

        // Loop through each document in our 'data' array
        data.forEach(function (doc) {
          // Add the document to the Lunr index so it can be searched
          this.add(doc);
          
          // *At the same time*, add the document's data to our 'store' object,
          // using its URL as the key. This is how we'll retrieve it later.
          store[doc.url] = { title: doc.title, content: doc.content };
        }, this); // 'this' is passed to forEach to maintain the Lunr context
      });

      // Now that the index is built, attach event listeners to the search box.
      // 'keyup' runs the search as the user types, making it feel "live".
      search.addEventListener('keyup', runSearch);
      // 'change' catches other inputs, like pasting text with the mouse.
      search.addEventListener('change', runSearch);
    })
    .catch(error => {
      // If the 'fetch' fails (e.g., file not found, network error),
      // log the error and show a user-friendly message.
      console.error('Error fetching search index:', error);
      results.innerHTML = '<p>Search functionality is temporarily unavailable.</p>';
      results.classList.add('active'); // Make sure the error is visible
    });

  // --- 5. Define the search function ---
  
  function runSearch() {
    // Get the current text from the search input box
    var query = search.value;
    
    // Clear any previous results from the list
    results.innerHTML = '';
    
    // Optimization: Don't run a search if the query is very short.
    // This avoids slow, meaningless searches for "a" or "i".
    if (query.length < 2) {
      results.classList.remove('active'); // Hide the results container
      return; // Stop the function
    }
    
    // --- CHANGE 2: Add wildcard to query for better position matching ---
    // We add a wildcard to the end. This makes Lunr return position
    // data for partial word matches (e.g., searching "java" finds "javascript").
    // We also run the search with the original query in case the user
    // is using their own wildcards.
    var searchResults = [];
    try {
      // Try searching with a wildcard appended for better metadata
      searchResults = index.search(query + '*');
      if (searchResults.length === 0) {
        // Fallback to the exact query the user typed
        searchResults = index.search(query);
      }
    } catch (e) {
      // Handle cases where the query is invalid (e.g., just a "+")
      console.warn("Invalid search query:", query, e);
      searchResults = []; // Ensure it's an empty array
    }
    // -------------------------------------------------------------------


    // Check if we found any results
    if (searchResults.length > 0) {
      // We have results! Show the results container.
      results.classList.add('active');
      
      // Create a header to show the result count
      var header = document.createElement('li');
      header.classList.add('search-header');
      header.innerHTML = `<h3>Found ${searchResults.length} results for "${query}"</h3>`;
      results.appendChild(header);

      // Loop through each result object in the 'searchResults' array
      searchResults.forEach(function (res) {
        // 'res.ref' is the URL we stored. Use it to get the full
        // document data (title, content) from our 'store' object.
        var doc = store[res.ref];
        
        // Create a new <li> element for this result
        var resultList = document.createElement('li');
        
        // --- CHANGE 2: Build a smart snippet ---
        var contentSnippet = '';
        var docContent = doc.content;
        var earliestPosition = Infinity;

        // 1. Get all match positions from the metadata
        var allPositions = [];
        // 'res.matchData.metadata' is an object where keys are the
        // search terms that matched (e.g., "javascript", "react")
        for (const term in res.matchData.metadata) {
          // For each term, find where it matched
          for (const field in res.matchData.metadata[term]) {
            // We only want to snippet the 'content' field
            if (field === 'content' && res.matchData.metadata[term][field].position) {
              
              // Add every start position (e.g., [120, 10]) to our list
              res.matchData.metadata[term][field].position.forEach(function(pos) {
                allPositions.push(pos[0]); // pos[0] is the start index
              });
            }
          }
        }

        // 2. Find the earliest (smallest) position
        if (allPositions.length > 0) {
          earliestPosition = Math.min(...allPositions);
        }

        // 3. Create the snippet
        var snippetStart = 0;
        var snippetEnd = 250; // Total snippet length
        var prefix = "";

        // If the first match is far into the document,
        // start the snippet ~80 chars *before* the match.
        if (earliestPosition !== Infinity && earliestPosition > 100) {
          snippetStart = earliestPosition - 80;
          snippetEnd = earliestPosition + 170; // (80 + 170 = 250)
          prefix = "..."; // Show we skipped the beginning
        }
        
        // Get the snippet from the full content
        contentSnippet = docContent.substring(snippetStart, snippetEnd);
        
        // Fallback: If something went wrong, just show the start of the doc
        if (!contentSnippet) {
          contentSnippet = docContent.substring(0, 250);
          prefix = "";
        }
        
        // Add the prefix and suffix
        contentSnippet = prefix + contentSnippet + '...';
        // -------------------------------------------

        // Build the HTML for this result item
        // Note: 'res.ref' is the URL, so it's used for the <a> link's href.
        resultList.innerHTML = `
          <a href="${res.ref}">
            <h4>${doc.title}</h4>
            <p>${contentSnippet}</p>
          </a>
        `;
        
        // Add the new <li> to the results <ul> on the page
        results.appendChild(resultList);
      });
    } else {
      // No results were found. Show a "No results" message.
      results.classList.add('active'); // Still show the container
      results.innerHTML = `<li><h3>No results found for "${query}"</h3></li>`;
    }
  }
})();